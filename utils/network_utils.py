import os
import platform
import requests
import socket
import speedtest as st
from datetime import datetime
import threading
from queue import Queue


def ping_target(target):
    """Ping the target to check if it's reachable."""
    param = "-n" if platform.system().lower() == "windows" else "-c"
    command = f"ping {param} 4 {target}"
    response = os.system(command)

    if response == 0:
        print(f"Target {target} is reachable.")
    else:
        print(f"Target {target} is not reachable.")


def traceroute_target(target):
    """Perform a traceroute to the target."""
    command = "tracert" if platform.system().lower() == "windows" else "traceroute"
    os.system(f"{command} {target}")


def get_public_ip():
    """Retrieve the public IP address of the machine running the scanner."""
    try:
        response = requests.get("https://api.ipify.org?format=json")
        if response.status_code == 200:
            return response.json().get("ip")
        else:
            print("Failed to retrieve public IP address.")
            return None
    except Exception as e:
        print(f"Error retrieving public IP address: {e}")
        return None


def check_local_open_ports(target):
    """Check open ports on the local machine using a basic socket connection."""
    print(f"Scanning open ports on {target} (local machine)...")
    open_ports = []
    for port in range(1, 1025):
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(0.5)
                if s.connect_ex((target, port)) == 0:
                    open_ports.append(port)
                    print(f"Port {port} is open.")
        except Exception as e:
            print(f"Error checking port {port}: {e}")
    if not open_ports:
        print("No open ports found.")
    else:
        print(f"Open ports: {open_ports}")


def check_internet_speed():
    """Check the internet speed of the machine running the scanner."""
    try:
        speed_test = st.Speedtest()
        print("Checking download speed...")
        download_speed = speed_test.download() / 1_000_000  # Convert to Mbps
        print(f"Download Speed: {download_speed:.2f} Mbps")

        print("Checking upload speed...")
        upload_speed = speed_test.upload() / 1_000_000  # Convert to Mbps
        print(f"Upload Speed: {upload_speed:.2f} Mbps")

        print("Checking ping...")
        ping_result = speed_test.results.ping
        print(f"Ping: {ping_result} ms")
    except Exception as e:
        print(f"Error checking internet speed: {e}")


def detect_operating_system(target):
    """Attempt to detect the operating system of the target using basic fingerprinting."""
    try:
        print(f"Attempting to detect operating system for {target}...")
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.settimeout(1)
            s.connect((target, 135))  # Port 135 is often used by Windows for RPC
            print(f"Port 135 is open on {target}, likely indicating a Windows system.")
            return "Windows"
    except socket.error:
        print(f"Port 135 is not open on {target}. Could be a non-Windows system or the port is filtered.")
        return "Unknown"

    # Additional fingerprinting logic could be added here for more accuracy
    return "Unknown"


def filter_cve_results(cve_data, severity_levels=None, start_date=None, end_date=None):
    """Filter CVE results based on severity and date range."""
    if severity_levels is None:
        severity_levels = ["LOW", "MEDIUM", "HIGH", "CRITICAL"]
    filtered_results = []

    for item in cve_data:
        cve_id = item.get("cve", {}).get("CVE_data_meta", {}).get("ID", "Unknown")
        description = item.get("cve", {}).get("description", {}).get("description_data", [])[0].get("value",
                                                                                                    "No description available")
        impact = item.get("impact", {}).get("baseMetricV3", {}).get("cvssV3", {}).get("baseSeverity", "UNKNOWN")
        published_date = item.get("publishedDate", "")

        # Check if severity is in specified levels
        if impact.upper() in severity_levels:
            # Check if date falls within the specified range
            if start_date or end_date:
                pub_date = datetime.strptime(published_date.split("T")[0], "%Y-%m-%d")
                if start_date and pub_date < start_date:
                    continue
                if end_date and pub_date > end_date:
                    continue
            filtered_results.append({
                "cve_id": cve_id,
                "description": description,
                "severity": impact,
                "published_date": published_date
            })

    return filtered_results


# Add multi-threading to detect OS for multiple targets
def detect_operating_systems_multithread(targets, num_threads=5):
    """Detect operating systems for multiple targets using multi-threading."""

    def worker(target_queue):
        while not target_queue.empty():
            target = target_queue.get()
            detect_operating_system(target)
            target_queue.task_done()

    target_queue = Queue()
    for target in targets:
        target_queue.put(target)

    threads = []
    for _ in range(num_threads):
        thread = threading.Thread(target=worker, args=(target_queue,))
        threads.append(thread)
        thread.start()

    for thread in threads:
        thread.join()

    print("Operating system detection complete for all targets.")